<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自动化JSON双向编辑器</title>
    <!-- 引入Tailwind CSS以实现快速美观的样式 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Marked.js用于解析Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- 引入highlight.js用于代码语法高亮 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- json-source-map 库将通过 ES 模块导入 -->
    <style>
        /* 自定义样式 */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            overflow: hidden; /* 防止body本身滚动 */
        }
        .json-key { color: #9cdcfe; }
        .json-string { color: #ce9178; }
        .json-number { color: #b5cea8; }
        .json-boolean { color: #569cd6; }
        .json-null { color: #569cd6; }
        .output-container pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .rendered-markdown {
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 0.5rem;
            background-color: #2d3748;
            cursor: pointer; /* 【新增】提示代码块可点击 */
        }
        .highlight {
            background-color: rgba(255, 229, 100, 0.2);
            transition: background-color 0.3s ease-in-out;
            border-radius: 4px;
        }
        .rendered-markdown pre {
            margin: 0;
        }
        /* 使可编辑的值有视觉提示 */
        [contenteditable="true"] {
            outline: none;
            border-bottom: 1px dashed rgba(255,255,255,0.3);
            cursor: text;
            padding: 0 2px;
        }
        [contenteditable="true"]:focus {
            border-bottom: 1px solid #63b3ed;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex flex-col h-screen max-w-7xl mx-auto p-4 sm:p-8">
        <header class="text-center mb-8 flex-shrink-0">
            <h1 class="text-4xl font-bold text-gray-100">自动化JSON双向编辑器</h1>
            <p class="text-lg text-gray-400 mt-2">专为包含Markdown代码块的JSON设计，支持双向编辑！</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 flex-grow min-h-0">
            <!-- 输入区域 -->
            <div class="flex flex-col min-h-0">
                <label for="json-input" class="text-lg font-semibold mb-2 text-gray-300 flex-shrink-0">JSON 输入 (双击高亮)</label>
                <textarea id="json-input" class="flex-grow bg-gray-800 border border-gray-700 rounded-lg p-4 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-300 overflow-auto" placeholder="请在此处粘贴您的JSON数据..."></textarea>
            </div>

            <!-- 输出区域 -->
            <div class="flex flex-col min-h-0">
                <label for="json-output" class="text-lg font-semibold mb-2 text-gray-300 flex-shrink-0">美化后输出 (单击代码块可编辑)</label>
                <div id="json-output" class="flex-grow bg-gray-800 border border-gray-700 rounded-lg p-4 output-container overflow-auto">
                    <p class="text-gray-500">这里将显示格式化后的内容...</p>
                </div>
            </div>
        </div>
         <div id="error-message" class="hidden"></div>
    </div>

    <script type="module">
        import jsonSourceMap from 'https://esm.sh/json-source-map@0.6.1';

        const jsonInputEl = document.getElementById('json-input');
        const outputDiv = document.getElementById('json-output');
        
        let currentJsonObject = null; 
        let renderTimeout;

        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        const renderAll = () => {
            const jsonInput = jsonInputEl.value;
            outputDiv.innerHTML = '';

            if (!jsonInput.trim()) {
                outputDiv.innerHTML = '<p class="text-gray-500">请输入JSON数据以自动渲染...</p>';
                currentJsonObject = null;
                return;
            }

            try {
                const result = jsonSourceMap.parse(jsonInput);
                currentJsonObject = result.data;
                const formattedHtml = formatJson(result.data, result.pointers, 0, '');
                outputDiv.innerHTML = formattedHtml;
                document.querySelectorAll('.output-container pre code').forEach(hljs.highlightElement);
                addCopyButtons();
            } catch (error) {
                currentJsonObject = null;
                console.error("Invalid JSON format (UI will remain blank):", error);
            }
        };

        const debouncedRender = debounce(renderAll, 500);
        jsonInputEl.addEventListener('input', debouncedRender);

        function formatJson(data, pointers, indent = 0, path = '') {
            const getLineData = (p) => pointers[p] ? `data-line="${pointers[p].key?.line ?? pointers[p].value.line}"` : '';
            const getPathData = (p) => `data-path="${p}"`;
            
            const indentStr = '&nbsp;'.repeat(indent * 4);
            const editableSpan = (type, value, currentPath) => `<span class="json-${type}" ${getPathData(currentPath)} contenteditable="true">${value}</span>`;

            if (data === null) return `<span class="json-null" ${getPathData(path)} contenteditable="true">null</span>`;
            if (typeof data === 'string') {
                if (data.includes('```')) {
                    // 【修正】: 为Markdown容器添加路径，以便之后定位
                    return `<div class="rendered-markdown" ${getPathData(path)}>${marked.parse(data)}</div>`;
                }
                return `<span class="json-string">"<span ${getPathData(path)} contenteditable="true">${escapeHtml(data)}</span>"</span>`;
            }
            if (typeof data === 'number') return editableSpan('number', data, path);
            if (typeof data === 'boolean') return editableSpan('boolean', data, path);
            
            if (Array.isArray(data)) {
                let html = '[\n';
                const items = data.map((item, index) => {
                    const newPath = `${path}/${index}`;
                    return `${'&nbsp;'.repeat((indent + 1) * 4)}<span ${getLineData(newPath)}>${formatJson(item, pointers, indent + 1, newPath)}</span>`;
                });
                html += items.join(',\n');
                html += `\n${indentStr}]`;
                return html;
            }

            if (typeof data === 'object') {
                let html = '{\n';
                const items = Object.keys(data).map(key => {
                    const newPath = `${path}/${escapeJsonPointer(key)}`;
                    return `${'&nbsp;'.repeat((indent + 1) * 4)}<span ${getLineData(newPath)}><span class="json-key">"${key}"</span>: ${formatJson(data[key], pointers, indent + 1, newPath)}</span>`;
                });
                html += items.join(',\n');
                html += `\n${indentStr}]`;
                return html;
            }
            return data;
        }

        function escapeJsonPointer(str) { return str.replace(/~/g, '~0').replace(/\//g, '~1'); }
        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }

        let highlightTimeout;
        function highlightLine(lineNumber) {
            if (typeof lineNumber !== 'number' || lineNumber < 0) return;
            clearTimeout(highlightTimeout);
            
            const previousHighlight = outputDiv.querySelector('.highlight');
            if (previousHighlight) previousHighlight.classList.remove('highlight');
            const targetElement = outputDiv.querySelector(`[data-line="${lineNumber}"]`);
            if (targetElement) {
                targetElement.classList.add('highlight');
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                highlightTimeout = setTimeout(() => targetElement.classList.remove('highlight'), 3000);
            }

            const lines = jsonInputEl.value.split('\n');
            if (lineNumber < lines.length) {
                let start = 0;
                for (let i = 0; i < lineNumber; i++) start += lines[i].length + 1;
                const end = start + lines[lineNumber].length;
                jsonInputEl.focus();
                jsonInputEl.setSelectionRange(start, end);
                const lineHeight = jsonInputEl.scrollHeight / lines.length;
                jsonInputEl.scrollTop = Math.max(0, (lineNumber * lineHeight) - (jsonInputEl.clientHeight / 2));
            }
        }
        
        jsonInputEl.addEventListener('dblclick', () => {
            const cursorPosition = jsonInputEl.selectionStart;
            const textUpToCursor = jsonInputEl.value.substring(0, cursorPosition);
            const currentLineNumber = (textUpToCursor.match(/\n/g) || []).length;
            highlightLine(currentLineNumber);
        });

        outputDiv.addEventListener('dblclick', (event) => {
            let target = event.target;
            while (target && target !== outputDiv) {
                if (target.hasAttribute('data-line')) {
                    const lineNumber = parseInt(target.getAttribute('data-line'), 10);
                    if (!isNaN(lineNumber)) highlightLine(lineNumber);
                    return;
                }
                target = target.parentElement;
            }
        });

        // --- 【新增和优化】: 单击和双击事件分离 ---
        outputDiv.addEventListener('click', (event) => {
            const markdownContainer = event.target.closest('.rendered-markdown');
            if (markdownContainer) {
                // 如果当前已经在编辑了，就不要再触发
                if (markdownContainer.querySelector('textarea')) return;

                const path = markdownContainer.getAttribute('data-path');
                if (!path) return;

                const originalMarkdown = getValueByPath(currentJsonObject, path);
                
                const textarea = document.createElement('textarea');
                textarea.className = 'w-full h-48 bg-gray-700 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-300';
                textarea.value = originalMarkdown;

                markdownContainer.innerHTML = '';
                markdownContainer.style.padding = '0';
                markdownContainer.appendChild(textarea);
                textarea.focus();

                textarea.addEventListener('blur', () => {
                    const newValue = textarea.value;
                    setValueByPath(currentJsonObject, path, newValue);
                    const newJsonString = JSON.stringify(currentJsonObject, null, 4);
                    jsonInputEl.value = newJsonString;
                    renderAll();
                });
            }
        });
        
        outputDiv.addEventListener('blur', (event) => {
            const target = event.target;
            if (target.hasAttribute('contenteditable') && target.hasAttribute('data-path')) {
                const path = target.getAttribute('data-path');
                let newValue = target.innerText;

                if (target.classList.contains('json-number')) {
                    newValue = parseFloat(newValue);
                    if (isNaN(newValue)) { renderAll(); return; } 
                } else if (target.classList.contains('json-boolean')) {
                    if (newValue.toLowerCase() === 'true') newValue = true;
                    else if (newValue.toLowerCase() === 'false') newValue = false;
                    else { renderAll(); return; }
                } else if (target.classList.contains('json-null')) {
                    if (newValue.toLowerCase() === 'null') newValue = null;
                    else { renderAll(); return; }
                }

                setValueByPath(currentJsonObject, path, newValue);
                
                const newJsonString = JSON.stringify(currentJsonObject, null, 4);
                const selectionStart = jsonInputEl.selectionStart;
                const scrollTop = jsonInputEl.scrollTop;

                jsonInputEl.value = newJsonString;
                renderAll();

                jsonInputEl.selectionStart = selectionStart;
                jsonInputEl.selectionEnd = selectionStart;
                jsonInputEl.scrollTop = scrollTop;
            }
        }, true);

        function getValueByPath(obj, path) {
            if (!obj || !path) return undefined;
            const keys = path.split('/').slice(1).map(k => k.replace(/~1/g, '/').replace(/~0/g, '~'));
            let current = obj;
            for (const key of keys) {
                if (typeof current === 'undefined') return undefined;
                current = current[key];
            }
            return current;
        }

        function setValueByPath(obj, path, value) {
            if (!obj) return;
            const keys = path.split('/').slice(1).map(k => k.replace(/~1/g, '/').replace(/~0/g, '~'));
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
                if (typeof current === 'undefined') return;
            }
            current[keys[keys.length - 1]] = value;
        }

        function addCopyButtons() {
            const codeBlocks = outputDiv.querySelectorAll('.rendered-markdown pre');
            codeBlocks.forEach(block => {
                block.parentElement.style.position = 'relative';
                const button = document.createElement('button');
                button.innerText = '复制';
                button.className = 'absolute top-2 right-2 bg-gray-600 hover:bg-gray-500 text-white text-xs py-1 px-2 rounded opacity-50 hover:opacity-100 transition-opacity';
                block.appendChild(button);
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const codeToCopy = block.querySelector('code').innerText;
                    copyToClipboard(codeToCopy);
                    button.innerText = '已复制!';
                    setTimeout(() => { button.innerText = '复制'; }, 2000);
                });
            });
        }

        function copyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try { document.execCommand('copy'); } 
            catch (err) { console.error('无法复制: ', err); }
            document.body.removeChild(textArea);
        }
    </script>
</body>
</html>
